{"componentChunkName":"component---node-modules-gatsby-theme-code-notes-src-templates-note-js","path":"/javascript-function-proprities/","result":{"data":{"mdx":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Spread Operator (...), Rest Parameters and Destructuring\",\n  \"tags\": [\"javascript\", \"destructuring\", \"spread operator\", \"rest parameters\"]\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h2\", {\n    \"id\": \"spread-operator-\"\n  }, \"Spread Operator (...)\"), mdx(\"p\", null, \"The apply() method of function object is a convenient tool for passing an array as arguments to a function. For example, it\\u2019s commonly used with the Math.max() method to find the highest value in an array. Consider this code fragment:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"const myArray = [5, 10, 50];\\nMath.max(myArray);   // Error: NaN\\nMath.max.apply(Math, myArray);    // 50\\n\")), mdx(\"p\", null, \"The Math.max() method doesn\\u2019t support arrays; it accepts only numbers. When an array is passed to the Math.max() function, it throws an error. But when the apply() method is used, the array is sent as individual numbers, so the Math.max() method can handle it.\"), mdx(\"p\", null, \"With the introduction of the spread operator, we no longer need to use the apply() method. With the spread operator, we can easily expand an expression into multiple arguments:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"const myArray = [5, 10, 50];\\nMath.max(...myArray);    // 50\\n\")), mdx(\"p\", null, \"Here, the spread operator expands myArray to create individual values for the function.\"), mdx(\"h2\", {\n    \"id\": \"rest-parameters\"\n  }, \"Rest Parameters\"), mdx(\"p\", null, \"The rest parameter has the same syntax as the spread operator, but instead of expanding an array into parameters, it collects parameters and turns them into an array. If there are no arguments, the rest parameter will be set to an empty array.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"function myFunction(...options) {\\n     return options;\\n}\\n\\nmyFunction('a', 'b', 'c');      // [\\\"a\\\", \\\"b\\\", \\\"c\\\"]\\n\")), mdx(\"p\", null, \"A rest parameter is particularly useful when creating a variadic function (a function that accepts a variable number of arguments). The rest operaroe must be the last argument; otherwise, a syntax error will occur. Another limitation is that only one rest parameter is allowed in the function declaration\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"function checkSubstrings(string, ...keys) {\\n  for (let key of keys) {\\n    if (string.indexOf(key) === -1) {\\n      return false;\\n    }\\n  }\\n  return true;\\n}\\n\\ncheckSubstrings('this is a string', 'is', 'this');   // true\\n\")), mdx(\"h3\", {\n    \"id\": \"destructuring\"\n  }, \"Destructuring\"), mdx(\"p\", null, \"Destructuring is a new feature that enables us to extract values from arrays and object and to assign them to variables using a syntax that is similar to object and array literals. The syntax is clear and easy to understand and is particularly useful when passing arguments to a function.\"), mdx(\"p\", null, \"A configuration object is often used to handle a large number of optional parameters, especially when the order of properties does not matter. Consider this function:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"function initiateTransfer(options) {\\n    let protocol = options.protocol,\\n        port = options.port,\\n        delay = options.delay,\\n        retries = options.retries,\\n        timeout = options.timeout,\\n        log = options.log;\\n\\n    // ...\\n    // code to initiate transfer\\n}\\n\\nconst options = {\\n    protocol: 'http',\\n    port: 800,\\n    delay: 150,\\n    retries: 10,\\n    timeout: 500,\\n    log: true\\n};\\n\\ninitiateTransfer(options);\\n\")), mdx(\"p\", null, \"This pattern is commonly used by JavaScript developers, and it works well, but we have to look inside the function body to see what parameters it expects. With destructured parameters, we can clearly indicate the parameters in the function declaration:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"function initiateTransfer({protocol, port, delay, retries, timeout, log}) {\\n    // ...\\n    // code to initiate transfer\\n};\\n\\nconst options = {\\n    protocol: 'http',\\n    port: 800,\\n    delay: 150,\\n    retries: 10,\\n    timeout: 500,\\n    log: true\\n}\\n\\ninitiateTransfer(options);\\n\")), mdx(\"p\", null, \"In this function, we\\u2019ve used an object destructuring pattern, instead of a configuration object. This makes our function not only more concise, but easier to read. We can also combine destructured parameters with regular ones. Note that a type error will be thrown if parameters are omitted in the function call:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"function initiateTransfer({protocol, port, delay, retries, timeout, log}) {\\n     // code to initiate transfer\\n}\\n\\ninitiateTransfer();  // TypeError: Cannot match against 'undefined' or 'null'\\n\")), mdx(\"p\", null, \"This is the desired behavior when we need parameters to be required, but what if we want them to be optional? To prevent this error when parameters are missing, we need to assign a default value to destructured parameters:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"function initiateTransfer({protocol, port, delay, retries, timeout, log} = {}) {\\n     // code to initiate transfer\\n}\\n\\ninitiateTransfer();    // no error\\n\")), mdx(\"p\", null, \"We can also assign a default value to each destructured parameter:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"function initiateTransfer({\\n    protocol = 'http',\\n    port = 800,\\n    delay = 150,\\n    retries = 10,\\n    timeout = 500,\\n    log = true }) {\\n     // code to initiate transfer\\n}\\n\")), mdx(\"p\", null, \"In this example, every property has a default parameter, eliminating the need for us to manually check for undefined parameters and assign default values inside the function body.\"), mdx(\"p\", null, \"In JavaScript, everything is passed by value, but when we pass a variable that refers to an object (including arrays), the \\u201Cvalue\\u201D is a reference to the object, and changing a property of an object referenced by a variable does change the underlying object.\"));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"title":"Spread Operator (...), Rest Parameters and Destructuring","tags":["javascript","destructuring","spread operator","rest parameters"],"emoji":null,"link":null},"fields":{"dateModified":"20th Jun 2020","slug":"/javascript-function-proprities/"},"tableOfContents":{"items":[{"url":"#spread-operator-","title":"Spread Operator (...)"},{"url":"#rest-parameters","title":"Rest Parameters","items":[{"url":"#destructuring","title":"Destructuring"}]}]},"parent":{"__typename":"File","relativePath":"javascript-function-proprities.md"}}},"pageContext":{"id":"fbeaacfa-a0f4-5ae1-9060-db42f9aa8a14","previous":null,"next":{"id":"092976bc-d151-52f1-8169-a62dda722811","frontmatter":{"title":"ES6 Modules","tags":["javascript"]},"fields":{"slug":"/es6-modules-syntax/"}},"hasUntagged":false,"basePath":"/"}}}